from pwn import *

# Opcodes
PUSH             = 0x0
POP              = 0x1
ADD              = 0x2
SUB              = 0x3
MUL              = 0x4
DIV              = 0x5
MOD              = 0x6
SHL              = 0x7
SHR              = 0x8
AND              = 0x9
OR               = 0x0B
XOR              = 0x0C
IF_TOP           = 0x0D
JMP              = 0x0E
JMP_IF_TOP       = 0x0F
JMP_IF_NOT_TOP   = 0x10
EQ               = 0x11
LT               = 0x12
GT               = 0x13
SET_REG          = 0x14
BSS_FROM_REG     = 0x15
REG_FROM_BSS     = 0x16
QUIT             = 0x17

def handle_line(line):

    # Comment
    if len(line) == 0 or line[0] ==  "#" or line[0] ==  ";":
        return b""

    data = line.split(" ")
    opcode = data[0]

    # Assembled code
    output = b""

    # Handle all opcodes here 
    if opcode == "PUSH":
        output += p8(PUSH)
        reg = int(data[1][1:])
        assert reg <= 3
        output += p8(reg, signed=True)

    elif opcode == "POP":
        output += p8(POP)
        reg = int(data[1][1:])
        assert reg >= 0 and reg <= 3
        output += p8(reg)

    elif opcode == "ADD":
        output += p8(ADD)
    
    elif opcode == "SUB":
        output += p8(SUB)
    
    elif opcode == "MUL":
        output += p8(MUL)
    
    elif opcode == "DIV":
        output += p8(DIV)
    
    elif opcode == "MOD":
        output += p8(MOD)

    elif opcode == "SHL":
        output += p8(SHL)

    elif opcode == "SHR":
        output += p8(SHR)

    elif opcode == "AND":
        output += p8(AND)

    elif opcode == "OR":
        output += p8(OR)

    elif opcode == "XOR":
        output += p8(XOR)

    elif opcode == "IF_TOP":
        output += p8(IF_TOP)
    
    elif opcode == "JMP":
        output += p8(JMP)
        size = int(data[1])
        output += p64(size)
    
    elif opcode == "JMP_IF_TOP":
        output += p8(JMP_IF_TOP)
        size = int(data[1])
        output += p64(size)

    elif opcode == "JMP_IF_NOT_TOP":
        output += p8(JMP_IF_NOT_TOP)
        size = int(data[1])
        output += p64(size)

    elif opcode == "EQ":
        output += p8(EQ)

    elif opcode == "LT":
        output += p8(LT)

    elif opcode == "GT":
        output += p8(GT)

    elif opcode == "SET_REG":
        output += p8(SET_REG)
        reg = int(data[1][1:])
        assert reg >= 0 and reg <= 3
        output += p8(reg)
        val = int(data[2], 16)
        output += p64(val)

    elif opcode == "BSS_FROM_REG":
        output += p8(BSS_FROM_REG)
        reg = int(data[1][1:])
        assert reg >= 0 and reg <= 3
        output += p8(reg)
        off = int(data[2], 16)
        output += p64(off)

    elif opcode == "REG_FROM_BSS":
        output += p8(REG_FROM_BSS)
        reg = int(data[1][1:])
        assert reg >= 0 and reg <= 3
        output += p8(reg)
        off = int(data[2], 16)
        output += p64(off)

    elif opcode == "QUIT":
        output += p8(QUIT)

    return output


def assemble_from_file(asm_file):
    
    with open(asm_file, "r") as f:
        assembly = f.readlines()

    bytecode = b""
    for line in assembly:
        bytecode += handle_line(line.strip("\n"))
    
    return bytecode

def assemble_from_str(s):
    bytecode = b""
    for line in s.split("\n"):
        bytecode += handle_line(line.strip("\n"))
    
    return bytecode

if __name__ == "__main__":
    asm_file = "test.asm"
    bytecode = assemble_from_file("test.asm")
    print([ord(i) for i in bytecode])