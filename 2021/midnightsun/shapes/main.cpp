
//You can compile this with g++ main.cpp -o main -g

#include <cstdio>
#include <cstring>
#include <cstdint>
#include <string>
#include <vector>
#include <cstdlib>
#include <unistd.h>
// #include <sys/socket.h>
// #include <netinet/in.h> 
#include <signal.h>

using namespace std;

char* flag1;
char* printCommand;

char retBuffer[1000];

class Shape {
	
	public:
		enum Type {Triangle, Square, Circle, Polygon};
		
		static vector<Shape*> allShapes;
		static Shape* GetShapeFromId(int theId) {
			//printf("Looking for shape ID %i\n", theId);
			for (std::vector<Shape*>::iterator it = Shape::allShapes.begin() ; it != Shape::allShapes.end(); ++it) {
				if ((*it)->id == theId) {
					return *it;
				}
			}
			sprintf(retBuffer, "Shape %i not found %i\n", theId);
			return NULL;
		}
		static Shape* GetShapeFromId(string theId) {
			
			//Make sure theId is a valid number
			const char* cstr = theId.c_str();
			char* goodNumber = (char*)malloc(strlen(cstr));
			int gnAt = 0;
			for (int i=0; i<strlen(cstr); i++) {
				if (cstr[i]>='0' and cstr[i]<='9'){
					goodNumber[gnAt++] = cstr[i];
				}
			}
			//Null terminate
			goodNumber[gnAt] = '\x00';
			
			int goodId = atoi(goodNumber);
			free(goodNumber);
			return Shape::GetShapeFromId(goodId);
		}
		
		
		uint16_t id;
		Type type;
		
		Shape() {
			
			allShapes.push_back((Shape*)this);
			
		}
		
};

vector<Shape*> Shape::allShapes;

class Triangle : public Shape {
	public:
		int x, y, angle, length;
		Triangle() {
			type = Type::Triangle;
			x = 0;
			y = 0;
			angle = 0;
			length = 0;
		}
		
		int GetLength() {
			return length;
		}
};

class Circle: public Shape {
	public:
		int x, y, size;
		Circle() {
			type = Type::Circle;
			x = 0;
			y = 0;
			size = 0;
		}
};

class Square: public Shape {
	public:
		int x, y, size;
		Square() {
			type = Type::Square;
		}
};

//New for 2020... the polygon!
class Polygon: public Shape {
	public:
	
		class Point {
			public: 
				int x, y;
		};
		
		Point *points;
		int numPoints;
		
		Polygon() {
			type = Type::Polygon;
			numPoints = 0;
			points = NULL;
		}
		
		~Polygon() {
			if (points != NULL) {
				free(points);
			}
		}
		
		void AddPoint(int newX, int newY) {
			points = (Point*)realloc(points, (numPoints+1)*sizeof(Point));
			points[numPoints].x = newX;
			points[numPoints].y = newY;
			numPoints += 1;
		}
		
		void ModPoint(int pointNum, int newX, int newY) {
			if (pointNum >= 0 and pointNum<numPoints) {
				points[pointNum].x = newX;
				points[pointNum].y = newY;
			} else {
				sprintf(retBuffer, "No");
			}
		}
		
		void PrintPoint(int pointNum) {
			if (pointNum >= 0 and pointNum<numPoints) {
				sprintf(retBuffer, "Point %i = %i, %i\n", pointNum, points[pointNum].x,points[pointNum].y);
			} else {
				sprintf(retBuffer, "No");
			}
		}
		
		void ResetPoints() {
			numPoints = 0;
			points = NULL;
		}
		
};

vector<string> SplitString(const string& str, const string& delim) {
    vector<string> tokens;
    size_t prev = 0, pos = 0;
    do
    {
        pos = str.find(delim, prev);
        if (pos == string::npos) pos = str.length();
        string token = str.substr(prev, pos-prev);
        if (!token.empty()) tokens.push_back(token);
        prev = pos + delim.length();
    }
    while (pos < str.length() && prev < str.length());
    return tokens;
}

void CommandReset() {
	printf("Clearing allShapes\n");
	
	for (std::vector<Shape*>::iterator it = Shape::allShapes.begin() ; it != Shape::allShapes.end(); ++it) { 
		//Polygon has its own destructor
		if ( (*it) -> type == Shape::Type::Polygon) {
			delete ( (Polygon*) *it);
		} else {
			delete *it;
		}
	}
	Shape::allShapes.clear();
}

//Create shape of a given type
void CommandCreate(string type) {
	
	//Find the first unused ID in all the shape objects (and check there's space)
	uint16_t lowestId = 0xFF;
	for (int i = 0; i < 0xFF; i++) {
		bool found = false;
		for (std::vector<Shape*>::iterator it = Shape::allShapes.begin() ; it != Shape::allShapes.end(); ++it) {
			if ((*it)->id == i) {
				found = true;
				break;
			}
		}
		if (!found) {
			lowestId = i;
			break;
		}
	}
	
	if (lowestId == 0xFF) {
		sprintf(retBuffer, "Error creating - too many objects.smarf\n");
		return;
	}
	
	sprintf(retBuffer, "Making a %s just for you, giving it id %i\n", type.c_str(), lowestId);
	Shape *newShape;
	if (type == "triangle") {
		Triangle *tri = new Triangle();
		newShape = (Shape*)tri;
	}
	if (type == "circle") {
		Circle *circle = new Circle();
		newShape = (Shape*)circle;
	}
	if (type == "square") {
		Square *square = new Square();
		newShape = (Shape*)square;
	}
	if (type == "polygon") {
		Polygon *poly = new Polygon();
		newShape = (Shape*)poly;
	}
	newShape -> id = lowestId;
	
}

void ProcessCommand(char *cmd) {
	
	vector<string> args = SplitString(cmd, ",");
	int numArgs = args.size();
	if ( numArgs == 0){
		return;
	}
	
	if (args[0] == "create" && numArgs == 2) {
		CommandCreate(args[1]);
		return;
	}
	
	if (args[0] == "print") {
		sprintf(retBuffer, "Executing print command: %s\n", printCommand);
		system(printCommand);
		return;
	}
	
	//In the full version there would be more commands to fulfil your shape management desires
	
	if (args[0] == "addpoint"&& numArgs == 4){
		Shape* thisShape = Shape::GetShapeFromId(args[1]);
		if (thisShape == NULL) return;
		if (thisShape->type != Shape::Type::Polygon) {
			sprintf(retBuffer, "Not a polygon!\n");
			return;
		}
		Polygon* poly = (Polygon*) thisShape;
		poly -> AddPoint(atoi(args[2].c_str()),atoi(args[3].c_str()));
	
		sprintf(retBuffer, "Added point, now has %i points\n", poly->numPoints);
		return;
	}
	
	if (args[0] == "getpoint"&& numArgs == 3){
		Shape* thisShape = Shape::GetShapeFromId(args[1]);
		if (thisShape == NULL) return;
		if (thisShape->type != Shape::Type::Polygon) {
			sprintf(retBuffer, "Not a polygon!\n");
			return;
		}
		Polygon* poly = (Polygon*) thisShape;
		poly -> PrintPoint(atoi(args[2].c_str()));
		return;
	}
	
	if (args[0] == "modpoint"&& numArgs == 5){
		Shape* thisShape = Shape::GetShapeFromId(args[1]);
		if (thisShape == NULL) return;
		if (thisShape->type != Shape::Type::Polygon) {
			sprintf(retBuffer, "Not a polygon!\n");
			return;
		}
		Polygon* poly = (Polygon*) thisShape;
		poly -> ModPoint(atoi(args[2].c_str()), atoi(args[3].c_str()), atoi(args[4].c_str()));
		sprintf(retBuffer, "Point modified\n");
		return;
	}
	
	if (args[0] == "circlesize" && numArgs == 3) {
		Shape* thisShape = Shape::GetShapeFromId(args[1]);
		if (thisShape == NULL) return;
		
		if (thisShape->type != Shape::Type::Circle) {
			sprintf(retBuffer, "Not a circle!\n");
			return;
		}
		Circle* thisCircle = (Circle*)Shape::GetShapeFromId(atoi(args[1].c_str()));
		thisCircle -> size = atoi(args[2].c_str());
		sprintf(retBuffer, "Circle size set\n");
		return;
	}
	
	sprintf(retBuffer, "Command not known");
	
}


int main( void ) {
	
	/** EDIT: Removing socket handling logic */
	/*
    struct sockaddr_in servaddr;
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    memset( &servaddr, 0, sizeof(servaddr));
    
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htons(INADDR_ANY);
    servaddr.sin_port = htons(1111);
    
    //Avoid address reuse errors, just in case it crashes ;)
    int t = 1;
    setsockopt(listen_fd,SOL_SOCKET,SO_REUSEADDR,&t,sizeof(int));
    
    if (bind(listen_fd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
		printf("Bind failed.\n");
		return 0;
	}
    
    if (listen(listen_fd, 10) <0){
		printf("listen failed.\n");
		return 0;
	}
	*/

	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);

	//Load flags and things
	printCommand = (char*) malloc(60);
	
	//These odd allocations aren't part of the vulnerability but it makes the first flag easier to find ;)
	void* readFile = malloc(20);
	void* readFile2 = malloc(20);
	void* readFile3 = malloc(20);
	
	//Read the flag from a file
	flag1 = (char*)malloc(20);
	FILE *f = fopen("flag1.txt", "rb");
	if (!f) {
		printf("flag1.txt was not found!\n");
		return 1;
	}
	
	fread(flag1, 1, 20, f);
	fclose(f);
	
	//This is the command used to send data to the printer
	strcpy(printCommand, "printer-invoke --printername printer1 --paper a1 --tray 2");
	
	//printf("Flag 1: %p\nPrint command: %p\n", flag1, printCommand);
	
	free(readFile);
	free(readFile2);
	free(readFile3);
	
	
	//Main server loop
	
	while (true) {
		/* EDIT: socket stuff
		int listenSock = -1;
		while(listenSock < 0) {
			listenSock = accept(listen_fd, (struct sockaddr*) NULL, NULL);
		}*/
		//printf("Client connected!\n");
		
		while(1) { 
			//Packet format: first byte is length, then that many bytes of data
			char buffer[255];
			int bufferAt = 0;
			memset(buffer, 0, 255);
			
			// int recVal = recv(listenSock, buffer, 1, 0);
			int recVal = read(0, buffer, 1);
			if (recVal <=0) {
				//socket closed
				break;
			}
			
			uint8_t toRead = buffer[0];
			
			while (toRead>0) {
				// int thisRead = recv(listenSock, buffer+bufferAt, toRead, 0);
				int thisRead = read(0, buffer+bufferAt, toRead);
				if (thisRead <= 0) {
					//socket closed
					break;
				}
				bufferAt += thisRead;
				toRead -= thisRead;
			}
			retBuffer[0] = 0;
			ProcessCommand(buffer);
			if (strlen(retBuffer)>0) {
				// send(listenSock, retBuffer, strlen(retBuffer), 0);
				write(1, retBuffer, strlen(retBuffer));
				//printf(retBuffer);
			}
		}
		printf("Socket closed probably, closing connection\n");
		// shutdown(listenSock, SHUT_RDWR);
		
		CommandReset();
		break; // EDIT: we only handle one client, exit here
	}
	return 0;
}
